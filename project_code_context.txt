
================================================================================
?? File Path: \cmd\config.go
================================================================================

package main

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/spf13/cobra"
)

var configCmd = &cobra.Command{
	Use:   "config",
	Short: "ç®¡ç†é…ç½®æ–‡ä»¶",
}

var configInitCmd = &cobra.Command{
	Use:   "init",
	Short: "ç”Ÿæˆé»˜è®¤é…ç½®æ–‡ä»¶",
	Run: func(cmd *cobra.Command, args []string) {
		home, _ := os.UserHomeDir()
		configPath := filepath.Join(home, ".kubehealer.yaml")

		// é»˜è®¤é…ç½®å†…å®¹
		content := `
# KubeHealer é…ç½®æ–‡ä»¶
monitor:
  namespace: "default"
  labels: ""
  interval: "5m"
`
		err := os.WriteFile(configPath, []byte(content), 0644)
		if err != nil {
			fmt.Printf("â?åˆ›å»ºå¤±è´¥: %v\n", err)
			return
		}
		fmt.Printf("âœ?é…ç½®æ–‡ä»¶å·²ç”Ÿæˆ? %s\n", configPath)
	},
}

func init() {
	rootCmd.AddCommand(configCmd)
	configCmd.AddCommand(configInitCmd)
}

================================================================================
?? File Path: \cmd\diagnose.go
================================================================================

package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"context"

	"github.com/swfoodt/kubehealer/pkg/diagnosis"
	"github.com/swfoodt/kubehealer/pkg/k8s"
	"github.com/swfoodt/kubehealer/pkg/report"

	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// å®šä¹‰å˜é‡å­˜å‚¨è¾“å‡ºæ ¼å¼
var outputFormat string

// diagnoseCmd ä»£è¡¨ diagnose å‘½ä»¤
var diagnoseCmd = &cobra.Command{
	Use:   "diagnose [pod-name]",
	Short: "è¯Šæ–­æŒ‡å®šçš?Pod",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		podName := args[0]

		// åªæœ‰åœ¨é»˜è®¤æ¨¡å¼ä¸‹æ‰æ‰“å°è¿™è¡Œï¼Œå¦åˆ™ä¼šæ±¡æŸ?Markdown è¾“å‡º
		if outputFormat == "" || outputFormat == "table" {
			logrus.Infof("ğŸ” æ­£åœ¨è¯Šæ–­ Pod: %s ...\n\n", podName)
		}

		// åˆå§‹åŒ–å®¢æˆ·ç«¯
		client, err := k8s.NewClient()
		if err != nil {
			logrus.Errorf("â?é”™è¯¯: æ— æ³•è¿æ¥é›†ç¾¤ - %v\n", err)
			os.Exit(1)
		}

		// è·å– Pod
		pod, err := client.Clientset.CoreV1().Pods("default").Get(context.TODO(), podName, metav1.GetOptions{})
		if err != nil {
			logrus.Errorf("â?é”™è¯¯: æ— æ³•æ‰¾åˆ° Pod %s - %v\n", podName, err)
			os.Exit(1)
		}

		// è°ƒç”¨åˆ†æå™?
		analyzer := diagnosis.NewAnalyzer(client.Clientset)
		result := analyzer.AnalyzePod(pod)

		// 3. æ ¹æ®å‚æ•°é€‰æ‹©è¾“å‡º
		switch outputFormat {
		case "md", "markdown":
			md := report.GenerateMarkdown(result)
			fmt.Println(md)
		case "json":
			// MarshalIndent ç”Ÿæˆå¸¦ç¼©è¿›çš„ JSON
			jsonData, err := json.MarshalIndent(result, "", "  ")
			if err != nil {
				logrus.Errorf("â?JSON åºåˆ—åŒ–å¤±è´? %v\n", err)
				os.Exit(1)
			}
			fmt.Println(string(jsonData))
		case "html":
			// è‡ªåŠ¨å½’æ¡£åˆ?reports ç›®å½•
			reportDir := "reports"
			if _, err := os.Stat(reportDir); os.IsNotExist(err) {
				_ = os.Mkdir(reportDir, 0755) // åˆ›å»ºç›®å½•
			}
			// åŠ¨æ€æ–‡ä»¶å
			timestamp := time.Now().Format("20060102_150405")
			// æ ¼å¼: reports/pod-name_report_timestamp.html
			fileName := fmt.Sprintf("%s_report_%s.html", podName, timestamp)
			fullPath := filepath.Join(reportDir, fileName)

			err := report.GenerateHTML(result, fullPath)
			if err != nil {
				logrus.Errorf("â?ç”Ÿæˆ HTML å¤±è´¥: %v\n", err)
				os.Exit(1)
			}
			// è·å–ç»å¯¹è·¯å¾„ï¼Œæ–¹ä¾¿ç”¨æˆ·ç‚¹å‡?
			absPath, _ := filepath.Abs(fullPath)
			logrus.Infof("âœ?è¯Šæ–­æŠ¥å‘Šå·²å½’æ¡? %s\n", absPath)

		default:
			report.PrintTable(result)
		}

		// æ‰“å° PID å’Œç¨‹åºé€€å‡ºæ ‡è®?
		logrus.Infof("\nğŸ [PID: %d] è¯Šæ–­ç»“æŸï¼Œç¨‹åºå³å°†é€€å‡ºã€‚\n", os.Getpid())

		// å¼ºåˆ¶å†™å…¥æ–°è¡Œï¼Œæ¸…é™¤ç»ˆç«¯æ®‹ç•™è¾“å…?è¾“å‡º
		fmt.Println()
	},
}

func init() {
	rootCmd.AddCommand(diagnoseCmd)

	// 2. ç»‘å®šå‚æ•° --output æˆ?-o
	diagnoseCmd.Flags().StringVarP(&outputFormat, "output", "o", "", "è¾“å‡ºæ ¼å¼ (table, md, json)")
}

================================================================================
?? File Path: \cmd\main.go
================================================================================

package main

func main() {
	Execute()
}

================================================================================
?? File Path: \cmd\monitor.go
================================================================================

package main

import (
	"fmt"
	"net/http"
	_ "net/http/pprof"
	"os"
	"os/signal"
	"path/filepath"
	"sync"
	"syscall"
	"time"

	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/swfoodt/kubehealer/pkg/diagnosis"
	"github.com/swfoodt/kubehealer/pkg/k8s"
	"github.com/swfoodt/kubehealer/pkg/report"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/informers"
	"k8s.io/client-go/tools/cache"
)

// å®šä¹‰è¿‡æ»¤å‚æ•°å˜é‡
var (
	monitorNamespace string
	monitorLabels    string
	monitorInterval  time.Duration
)

var monitorCmd = &cobra.Command{
	Use:   "monitor",
	Short: "å®æ—¶ç›‘æ§ Pod çŠ¶æ€å˜åŒ?(Informeræ¨¡å¼)",
	Long:  `å¯åŠ¨ä¸€ä¸ªé•¿è¿è¡Œè¿›ç¨‹ï¼Œç›‘å¬é›†ç¾¤å†… Pod çš„åˆ›å»ºã€æ›´æ–°å’Œåˆ é™¤äº‹ä»¶ã€‚æ”¯æŒé€šè¿‡ Namespace å’?Label è¿›è¡Œè¿‡æ»¤ã€‚`,
	Run: func(cmd *cobra.Command, args []string) {
		// å¯åŠ¨ Pprof æ€§èƒ½åˆ†ææœåŠ¡å™?(åå°è¿è¡Œ)
		// ç›‘å¬ 6060 ç«¯å£ï¼Œä¸é˜»å¡ä¸»ç¨‹åº?
		go func() {
			logrus.Info("ğŸ•µï¸?Pprof æ€§èƒ½ç›‘æ§å·²å¯åŠ? http://localhost:6060/debug/pprof")
			if err := http.ListenAndServe("0.0.0.0:6060", nil); err != nil {
				logrus.Warnf("Pprof å¯åŠ¨å¤±è´¥: %v", err)
			}
		}()
		// ä»?Viper è·å–æœ€ç»ˆé…ç½?(è¦†ç›–å…¨å±€å˜é‡)
		// å¦‚æœå‘½ä»¤è¡Œæ²¡ä¼ ï¼Œå°±ç”¨é…ç½®æ–‡ä»¶çš„ï¼›å¦‚æœä¼ äº†ï¼ŒViper ä¼šè‡ªåŠ¨ç”¨å‘½ä»¤è¡Œçš„
		ns := viper.GetString("monitor.namespace")
		labels := viper.GetString("monitor.labels")
		interval := viper.GetDuration("monitor.interval")

		logrus.Info("ğŸš€ å¯åŠ¨ KubeHealer ç›‘æ§æ¨¡å¼(ctrl+cé€€å‡?...")
		logrus.Infof("   - ç›‘å¬ Namespace: %s\n", ns)
		logrus.Infof("   - ç›‘å¬ Labels: %s\n", labels)
		logrus.Infof("   - åŒæ­¥é—´éš”: %s\n", interval)

		// åˆå§‹åŒ–å®¢æˆ·ç«¯
		client, err := k8s.NewClient()
		if err != nil {
			logrus.Errorf("â?è¿æ¥å¤±è´¥: %v\n", err)
			os.Exit(1)
		}

		// åˆ›å»º SharedInformerFactory (å¸¦è¿‡æ»¤é€‰é¡¹)
		// ä½¿ç”¨ WithOptions æ”¯æŒ Namespace å’?LabelSelector
		var factory informers.SharedInformerFactory

		// æ„é€?ListOptions
		tweakListOptions := func(options *metav1.ListOptions) {
			if labels != "" {
				options.LabelSelector = labels
			}
		}

		if ns != "" {
			// å¦‚æœæŒ‡å®šäº?Namespaceï¼Œåªç›‘å¬è¯?Namespace
			factory = informers.NewSharedInformerFactoryWithOptions(
				client.Clientset,
				interval,
				informers.WithNamespace(ns),
				informers.WithTweakListOptions(tweakListOptions),
			)
		} else {
			// å¦åˆ™ç›‘å¬æ‰€æœ?Namespace
			factory = informers.NewSharedInformerFactoryWithOptions(
				client.Clientset,
				interval,
				informers.WithTweakListOptions(tweakListOptions),
			)
		}

		// è·å– Pod çš?Informer
		podInformer := factory.Core().V1().Pods().Informer()

		// æ³¨å†Œäº‹ä»¶å¤„ç†å‡½æ•°
		podInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				pod := obj.(*corev1.Pod)
				logrus.Infof("[â?Added] %s/%s (Status: %s)\n", pod.Namespace, pod.Name, pod.Status.Phase)

				if pod.Status.Phase != corev1.PodRunning && pod.Status.Phase != corev1.PodSucceeded {
					go triggerDiagnosis(pod, client)
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldPod := oldObj.(*corev1.Pod)
				newPod := newObj.(*corev1.Pod)

				// ã€ä¿®å¤ã€‘å®‰å…¨åœ°è·å–é‡å¯æ¬¡æ•°
				// å¦‚æœ Pod å¤„äº Pending çŠ¶æ€ï¼ŒContainerStatuses å¯èƒ½æ˜¯ç©ºçš„ï¼Œç›´æ¥è®¿é—® [0] ä¼?panic
				var oldRestarts, newRestarts int32
				if len(oldPod.Status.ContainerStatuses) > 0 {
					oldRestarts = oldPod.Status.ContainerStatuses[0].RestartCount
				}
				if len(newPod.Status.ContainerStatuses) > 0 {
					newRestarts = newPod.Status.ContainerStatuses[0].RestartCount
				}

				// åªæœ‰çŠ¶æ€å‘ç”Ÿå®è´¨å˜åŒ–æ‰å…³å¿ƒ (Phase å˜äº†ï¼Œæˆ–è€…é‡å¯æ¬¡æ•°å˜äº?
				if oldPod.Status.Phase == newPod.Status.Phase && oldRestarts == newRestarts {
					// fmt.Println("Resync triggered for", newPod.Name) //æµ‹è¯•-intervalåŠŸèƒ½ç”?
					return
				}

				logrus.Infof("[ğŸ”„ Updated] %s/%s: %s -> %s (Restarts: %d)\n",
					newPod.Namespace, newPod.Name, oldPod.Status.Phase, newPod.Status.Phase,
					newRestarts)

				// è‡ªåŠ¨è¯Šæ–­é€»è¾‘
				// å¦‚æœå˜æˆäº†é Running çŠ¶æ€ï¼Œæˆ–è€…é‡å¯æ¬¡æ•°å¢åŠ äº†
				isCrashLoop := newRestarts > oldRestarts
				if newPod.Status.Phase != corev1.PodRunning || isCrashLoop {
					go triggerDiagnosis(newPod, client)
				}
			},
			DeleteFunc: func(obj interface{}) {
				pod, ok := obj.(*corev1.Pod)
				if !ok {
					tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
					if !ok {
						return
					}
					pod, ok = tombstone.Obj.(*corev1.Pod)
					if !ok {
						return
					}
				}
				logrus.Errorf("[â?Deleted] %s/%s\n", pod.Namespace, pod.Name)
			},
		})

		// å¯åŠ¨
		stopper := make(chan struct{})
		defer close(stopper)
		factory.Start(stopper)

		logrus.Info("â?æ­£åœ¨åŒæ­¥ç¼“å­˜...")
		if !cache.WaitForCacheSync(stopper, podInformer.HasSynced) {
			logrus.Error("â?ç¼“å­˜åŒæ­¥è¶…æ—¶")
			return
		}
		logrus.Info("âœ?å¼€å§‹ç›‘å?..")

		// ä¼˜é›…é€€å‡?
		sigCh := make(chan os.Signal, 1)
		signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
		<-sigCh
		logrus.Info("\nğŸ‘‹ æ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œæ­£åœ¨é€€å‡?..")
	},
}

// å»é‡ç¼“å­˜ (PodUID -> ä¸Šæ¬¡è¯Šæ–­æ—¶é—´)
// ä½¿ç”¨ sync.Map ä¿è¯å¹¶å‘å®‰å…¨
var diagnosisCooldown sync.Map

// triggerDiagnosis è§¦å‘ä¸€æ¬¡è¯Šæ–­å¹¶ç”ŸæˆæŠ¥å‘Š
func triggerDiagnosis(pod *corev1.Pod, client *k8s.Client) {
	// å»é‡æ£€æŸ?
	// å†·å´æ—¶é—´è®¾ç½®ä¸?1 åˆ†é’Ÿ
	const cooldownPeriod = 1 * time.Minute

	// è·å–ä¸Šæ¬¡è¯Šæ–­æ—¶é—´
	if lastTime, loaded := diagnosisCooldown.Load(pod.UID); loaded {
		if time.Since(lastTime.(time.Time)) < cooldownPeriod {
			// å¦‚æœè¿˜åœ¨å†·å´æœŸå†…ï¼Œç›´æ¥è·³è¿?
			logrus.Infof("â?[%s] å¤„äºå†·å´æœŸï¼Œè·³è¿‡é‡å¤è¯Šæ–­\n", pod.Name)
			return
		}
	}

	// è®°å½•æœ¬æ¬¡è¯Šæ–­æ—¶é—´ (ç›¸å½“äºæ›´æ–°ç¼“å­?
	diagnosisCooldown.Store(pod.UID, time.Now())

	// åˆå§‹åŒ–åˆ†æå™¨ (ä»¥ä¸‹é€»è¾‘ä¿æŒä¸å˜)
	analyzer := diagnosis.NewAnalyzer(client.Clientset)
	result := analyzer.AnalyzePod(pod)

	// ç”ŸæˆæŠ¥å‘Š
	reportDir := "reports"
	if _, err := os.Stat(reportDir); os.IsNotExist(err) {
		_ = os.Mkdir(reportDir, 0755)
	}

	timestamp := time.Now().Format("20060102_150405")
	fileName := fmt.Sprintf("%s_auto_%s.html", pod.Name, timestamp)
	fullPath := filepath.Join(reportDir, fileName)

	err := report.GenerateHTML(result, fullPath)
	if err != nil {
		logrus.Errorf("â?[%s] æŠ¥å‘Šç”Ÿæˆå¤±è´¥: %v\n", pod.Name, err)
	} else {
		absPath, _ := filepath.Abs(fullPath)
		logrus.Infof("ğŸš¨ [%s] å¼‚å¸¸æ£€æµ? è¯Šæ–­æŠ¥å‘Šå·²ç”Ÿæˆ? %s\n", pod.Name, absPath)
	}
}

func init() {
	rootCmd.AddCommand(monitorCmd)
	// æ³¨å†Œ Flags
	monitorCmd.Flags().StringVarP(&monitorNamespace, "namespace", "n", "", "æŒ‡å®šç›‘æ§çš?Namespace (é»˜è®¤ä¸ºæ‰€æœ?")
	monitorCmd.Flags().StringVarP(&monitorLabels, "label-selector", "l", "", "æŒ‡å®šç›‘æ§çš?Label Selector (ä¾‹å¦‚: app=nginx)")
	// é»˜è®¤ 10 åˆ†é’ŸåŒæ­¥ä¸€æ¬¡ï¼Œé¿å…é•¿æ—¶é—´è¿è¡Œå¯¼è‡´ç¼“å­˜æ¼‚ç§?
	monitorCmd.Flags().DurationVarP(&monitorInterval, "interval", "i", 10*time.Minute, "Informer å…¨é‡åŒæ­¥æ—¶é—´é—´éš” (ä¾‹å¦‚ 10m, 1h)")

	// 2. ç»‘å®š Viper (è®?Viper çŸ¥é“è¿™äº› Flag çš„å­˜åœ?
	viper.BindPFlag("monitor.namespace", monitorCmd.Flags().Lookup("namespace"))
	viper.BindPFlag("monitor.labels", monitorCmd.Flags().Lookup("label-selector"))
	viper.BindPFlag("monitor.interval", monitorCmd.Flags().Lookup("interval"))
}

================================================================================
?? File Path: \cmd\report.go
================================================================================

package main

import (
	"fmt"
	"os"
	"strings"

	"github.com/olekukonko/tablewriter"
	"github.com/spf13/cobra"
)

// reportCmd ä»£è¡¨ report å‘½ä»¤
var reportCmd = &cobra.Command{
	Use:   "report",
	Short: "ç®¡ç†å†å²è¯Šæ–­æŠ¥å‘Š",
	Long:  `æŸ¥çœ‹ã€æ‰“å¼€æˆ–ç®¡ç†ç”Ÿæˆçš„ HTML è¯Šæ–­æŠ¥å‘Šã€‚`,
}

// reportListCmd ä»£è¡¨ report list å­å‘½ä»?
var reportListCmd = &cobra.Command{
	Use:   "list",
	Short: "åˆ—å‡ºæ‰€æœ‰å†å²æŠ¥å‘?,
	Run: func(cmd *cobra.Command, args []string) {
		reportDir := "reports"

		// è¯»å–ç›®å½•
		files, err := os.ReadDir(reportDir)
		if err != nil {
			if os.IsNotExist(err) {
				fmt.Println("ğŸ“­ æš‚æ— å†å²æŠ¥å‘Š (reports ç›®å½•ä¸å­˜åœ?")
				return
			}
			fmt.Printf("â?è¯»å–ç›®å½•å¤±è´¥: %v\n", err)
			return
		}

		// å‡†å¤‡è¡¨æ ¼æ•°æ®
		var data [][]string
		for _, file := range files {
			if file.IsDir() || !strings.HasSuffix(file.Name(), ".html") {
				continue
			}

			info, _ := file.Info()
			size := fmt.Sprintf("%.1f KB", float64(info.Size())/1024)
			modTime := info.ModTime().Format("2006-01-02 15:04:05")

			// ä»æ–‡ä»¶åè§£æ Pod åç§°
			// æ ¼å¼: podname_report_timestamp.html
			name := file.Name()
			podName := "Unknown"
			if parts := strings.Split(name, "_report_"); len(parts) > 0 {
				podName = parts[0]
			}

			data = append(data, []string{modTime, podName, size, name})
		}

		if len(data) == 0 {
			fmt.Println("ğŸ“­ æš‚æ— å†å²æŠ¥å‘Š")
			return
		}

		// æ¸²æŸ“è¡¨æ ¼
		fmt.Printf("ğŸ“‚ å†å²æŠ¥å‘Šåˆ—è¡¨ (%s):\n", reportDir)
		table := tablewriter.NewWriter(os.Stdout)
		table.SetHeader([]string{"ç”Ÿæˆæ—¶é—´", "Pod åç§°", "å¤§å°", "æ–‡ä»¶å?})
		table.SetBorder(false)
		table.AppendBulk(data)
		table.Render()
	},
}

func init() {
	rootCmd.AddCommand(reportCmd)
	reportCmd.AddCommand(reportListCmd)
}

================================================================================
?? File Path: \cmd\root.go
================================================================================

package main

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/swfoodt/kubehealer/pkg/util"
)

// å…¨å±€å˜é‡
var (
	cfgFile string // é…ç½®æ–‡ä»¶è·¯å¾„
	debug   bool   // æ˜¯å¦å¼€å¯è°ƒè¯•æ¨¡å¼?
)

// rootCmd ä»£è¡¨æ²¡æœ‰è°ƒç”¨å­å‘½ä»¤æ—¶çš„åŸºç¡€å‘½ä»¤
var rootCmd = &cobra.Command{
	Use:   "kubehealer",
	Short: "KubeHealer: K8s å®¹å™¨å±‚è¯Šæ–­å·¥å…?,
	Long:  `ä¸€ä¸ªåŸºäº?Go + client-go çš?Kubernetes è¯Šæ–­å·¥å…·ï¼Œç”¨äºå¿«é€Ÿå®šä½?Pod å¼‚å¸¸ã€‚`,
	//åœ¨æ­¤å¤„å¯ä»¥æ·»åŠ å…¨å±€ flagï¼Œä¾‹å¦?--kubeconfig
}

// Execute å°†æ‰€æœ‰å­å‘½ä»¤æ·»åŠ åˆ°æ ¹å‘½ä»¤å¹¶è®¾ç½®æ ‡å¿?
func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

func init() {
	cobra.OnInitialize(initConfig)

	// å…¨å±€å‚æ•°: --config
	rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "é…ç½®æ–‡ä»¶ (é»˜è®¤ä¸?$HOME/.kubehealer.yaml)")
	rootCmd.PersistentFlags().BoolVar(&debug, "debug", false, "å¼€å¯è°ƒè¯•æ¨¡å¼?(æ˜¾ç¤ºè¯¦ç»†æ—¥å¿—)")
}

// initConfig è¯»å–é…ç½®æ–‡ä»¶å’Œç¯å¢ƒå˜é‡?
func initConfig() {
	if cfgFile != "" {
		// ä½¿ç”¨å‚æ•°æŒ‡å®šçš„é…ç½®æ–‡ä»?
		viper.SetConfigFile(cfgFile)
	} else {
		// æŸ¥æ‰¾ home ç›®å½•
		home, err := os.UserHomeDir()
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}

		// æœç´¢è·¯å¾„: home ç›®å½•
		viper.AddConfigPath(home)
		// æœç´¢æ–‡ä»¶å? .kubehealer (æ— éœ€åç¼€)
		viper.SetConfigType("yaml")
		viper.SetConfigName(".kubehealer")
	}

	// è¯»å–ç¯å¢ƒå˜é‡ (è‡ªåŠ¨å°?KUBEHEALER_NAMESPACE æ˜ å°„ä¸?namespace)
	viper.SetEnvPrefix("KUBEHEALER")
	viper.AutomaticEnv()

	// å°è¯•è¯»å–é…ç½®
	if err := viper.ReadInConfig(); err == nil {
		fmt.Println("âš™ï¸  å·²åŠ è½½é…ç½®æ–‡ä»?", viper.ConfigFileUsed())
	}

	// åœ¨é…ç½®è¯»å–å®Œåï¼Œåˆå§‹åŒ–æ—¥å¿?
	util.InitLogger(debug)

	if err := viper.ReadInConfig(); err == nil {
		// ä½¿ç”¨ logrus æ‰“å°ï¼Œè€Œä¸æ˜?fmt
		// logrus.Infof("âš™ï¸ å·²åŠ è½½é…ç½®æ–‡ä»? %s", viper.ConfigFileUsed())
		// æ³¨æ„ï¼šè¿™é‡Œå¯èƒ½è¿˜æ²¡æ³•ç›´æ¥ç”?logrusï¼Œå› ä¸?import å¾ªç¯é—®é¢˜
		// æš‚æ—¶åœ?initConfig é‡Œè¿˜æ˜¯å¯ä»¥ç”¨ fmt æˆ–è€…ç›´æ¥è°ƒ logrus
	}
}

================================================================================
?? File Path: \cmd\server.go
================================================================================

package main

import (
	"fmt"
	"net/http"
	"os"

	"github.com/spf13/cobra"
)

var port string

var serverCmd = &cobra.Command{
	Use:   "server",
	Short: "å¯åŠ¨ Web æœåŠ¡å™¨å±•ç¤ºè¯Šæ–­æŠ¥å‘?,
	Long:  `å¯åŠ¨ä¸€ä¸ªè½»é‡çº§ HTTP æœåŠ¡å™¨ï¼Œæ‰˜ç®¡ reports ç›®å½•ï¼Œå…è®¸é€šè¿‡æµè§ˆå™¨æŸ¥çœ‹å†å²æŠ¥å‘Šã€‚`,
	Run: func(cmd *cobra.Command, args []string) {
		reportDir := "reports"

		// ç¡®ä¿ç›®å½•å­˜åœ¨
		if _, err := os.Stat(reportDir); os.IsNotExist(err) {
			_ = os.Mkdir(reportDir, 0755)
		}

		// æ ¸å¿ƒé€»è¾‘ï¼šå°† reportDir ç›®å½•ä½œä¸ºä¸€ä¸ªé™æ€æ–‡ä»¶æœåŠ¡å™¨
		fs := http.FileServer(http.Dir(reportDir))

		// æ³¨å†Œè·¯ç”±: "/"
		http.Handle("/", http.StripPrefix("/", fs))

		fmt.Printf("ğŸŒ Web æœåŠ¡å™¨å·²å¯åŠ¨: http://localhost:%s\n", port)
		fmt.Printf("ğŸ“‚ æ‰˜ç®¡ç›®å½•: ./%s\n", reportDir)
		fmt.Println("æŒ?Ctrl+C åœæ­¢æœåŠ¡...")

		// å¯åŠ¨ç›‘å¬
		err := http.ListenAndServe(":"+port, nil)
		if err != nil {
			fmt.Printf("â?å¯åŠ¨å¤±è´¥: %v\n", err)
			os.Exit(1)
		}
	},
}

func init() {
	rootCmd.AddCommand(serverCmd)
	// æ”¯æŒè‡ªå®šä¹‰ç«¯å£ï¼Œé»˜è®¤ä¸?8080
	serverCmd.Flags().StringVarP(&port, "port", "p", "8080", "Web æœåŠ¡å™¨ç›‘å¬ç«¯å?)
}

================================================================================
?? File Path: \pkg\diagnosis\analyzer.go
================================================================================

package diagnosis

import (
	"context"
	"fmt"
	"sort"
	"strings"
	"time"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
)

type Analyzer struct {
	client kubernetes.Interface
	engine *RuleEngine // è¯Šæ–­å¼•æ“
}

func NewAnalyzer(client kubernetes.Interface) *Analyzer {
	return &Analyzer{
		client: client,
		engine: NewRuleEngine(), // åˆå§‹åŒ–è¯Šæ–­å¼•æ“?
	}
}

// AnalyzePod ç¼–æ’è¯Šæ–­æµç¨‹
func (a *Analyzer) AnalyzePod(pod *corev1.Pod) DiagnosisResult {
	result := DiagnosisResult{
		PodName:      pod.Name,
		Namespace:    pod.Namespace,
		NodeName:     pod.Spec.NodeName,
		Phase:        string(pod.Status.Phase),
		RestartCount: SumRestarts(pod),
		Containers:   []ContainerDiagnosis{},
		Events:       a.GetPodEvents(pod), // è·å–äº‹ä»¶åˆ—è¡¨
	}
	// éå†å®¹å™¨è¿›è¡Œè¯Šæ–­
	for _, cs := range pod.Status.ContainerStatuses {
		// å¯»æ‰¾å¯¹åº”çš?Container Spec
		var targetContainer *corev1.Container
		for i := range pod.Spec.Containers {
			if pod.Spec.Containers[i].Name == cs.Name {
				targetContainer = &pod.Spec.Containers[i]
				break
			}
		}

		// è·å–å•å®¹å™¨è¯Šæ–­ç»“æ?
		containerDiag := a.GetContainerDiagnosis(pod, cs, targetContainer)
		result.Containers = append(result.Containers, containerDiag)
	}

	// å¦‚æœ Pod æ˜?Pending ä¸”æ²¡æœ‰å®¹å™¨çŠ¶æ€ï¼Œæ‰‹åŠ¨è§¦å‘ä¸€æ¬¡è¯Šæ–?
	if len(pod.Status.ContainerStatuses) == 0 && pod.Status.Phase == corev1.PodPending {
		// æ„é€ è™šæ‹ŸçŠ¶æ€è§¦å‘æ£€æŸ?æ„é€ ä¸€ä¸ªç©ºçš?dummy çŠ¶æ€ï¼Œä¸ºäº†è§¦å‘ PendingRule
		dummyStatus := corev1.ContainerStatus{Name: "n/a"}
		containerDiag := a.GetContainerDiagnosis(pod, dummyStatus, nil)
		// å¦‚æœçœŸçš„å‘ç°äº†é—®é¢˜ï¼ˆæ¯”å¦‚ PendingRule å‘½ä¸­äº†ï¼‰ï¼Œæ‰åŠ è¿›å?
		if len(containerDiag.Issues) > 0 {
			result.Containers = append(result.Containers, containerDiag)
		}
	}

	return result
}

// GetContainerDiagnosis è¿”å› ContainerDiagnosis ç»“æ„ä½?
func (a *Analyzer) GetContainerDiagnosis(pod *corev1.Pod, cs corev1.ContainerStatus, containerSpec *corev1.Container) ContainerDiagnosis {
	diag := ContainerDiagnosis{
		Name:   cs.Name,
		Ready:  cs.Ready,
		Issues: []Issue{},
	}

	// å¡«å……åŸºç¡€çŠ¶æ€ä¿¡æ?
	if cs.State.Waiting != nil {
		diag.State = "Waiting"
		diag.Reason = cs.State.Waiting.Reason
		diag.Message = cs.State.Waiting.Message
	} else if cs.State.Terminated != nil {
		diag.State = "Terminated"
		diag.Reason = cs.State.Terminated.Reason
		diag.Message = cs.State.Terminated.Message
		diag.ExitCode = cs.State.Terminated.ExitCode
	} else if cs.State.Running != nil {
		diag.State = "Running"
	}

	// å¡«å……èµ„æºé…ç½®
	if containerSpec != nil {
		diag.ResourceInfo = a.GetResourceInfo(*containerSpec)
	}

	// ----------------------------------------------------
	// è§„åˆ™å¼•æ“ä»‹å…¥
	// ----------------------------------------------------
	ruleResult := a.engine.Run(pod, containerSpec, cs)
	if ruleResult != nil {
		issueType := "Warning"
		if ruleResult.Title == "å†…å­˜æº¢å‡º (OOMKilled)" {
			issueType = "Error"
		}

		diag.Issues = append(diag.Issues, Issue{
			Type:       issueType,
			Title:      ruleResult.Title,
			RawError:   ruleResult.RawError,
			Suggestion: ruleResult.Suggestion,
		})
	}

	// æ£€æŸ?LastTerminationState (å…œåº•è¡¥å……)
	// å¦‚æœè§„åˆ™å¼•æ“æ²¡æœ‰è¦†ç›–è¿™éƒ¨åˆ†ï¼Œå¯ä»¥åœ¨è¿™é‡Œè¡¥å…?Issueï¼Œæˆ–è€…å®Œå…¨ä¾èµ–è§„åˆ™å¼•æ“ã€?
	// ç›®å‰ä¸ºäº†ä¿æŒé€»è¾‘å®Œæ•´ï¼Œæˆ‘ä»¬è¿˜æ˜¯åŠ ä¸Šè¿™ä¸ªæ£€æŸ¥ï¼Œä½œä¸º Issue æ·»åŠ è¿›å»ã€?
	if cs.LastTerminationState.Terminated != nil {
		// last := cs.LastTerminationState.Terminated
		// å¦‚æœè§„åˆ™å¼•æ“è¿˜æ²¡æŠ?OOMï¼Œè¿™é‡Œè¡¥å……ä¿¡æ?
		// (ç®€å•èµ·è§ï¼Œè¿™é‡Œæˆ‘ä»¬åªæŠŠä¸Šæ¬¡é€€å‡ºä½œä¸ºä¸€æ?Info çº§åˆ«çš?Issue æˆ–è€…æ‹¼æ¥åœ¨ Reason é‡Œï¼Ÿ)
		// ä¸ºäº†ç»“æ„åŒ–ï¼Œæˆ‘ä»¬æš‚æ—¶ä¸åœ¨è¿™é‡ŒåŠ ï¼Œå› ä¸º Day 13 çš„è§„åˆ™å¼•æ“åº”è¯¥å·²ç»å¤„ç†äº† OOMã€?
		// å¦‚æœåªæ˜¯æ™®é€šé€€å‡ºï¼Œæˆ‘ä»¬è¿™é‡Œä¸éœ€è¦é¢å¤–å¤„ç†ï¼Œé™¤éæƒ³å±•ç¤ºå†å²ã€?
	}

	// ----------------------------------------------------
	// æ—¥å¿—åˆ†æ (Day 27)
	// ----------------------------------------------------
	// åªæœ‰å½“å®¹å™¨ä¸æ­£å¸¸ (é?Running) æˆ–è€…æœ‰é‡å¯è®°å½•æ—¶ï¼Œæ‰å»æŠ“æ—¥å¿?
	// é¿å…æŠ“å–æ­£å¸¸è¿è¡Œçš„æ—¥å¿—æµªè´¹èµ„æº?
	if cs.State.Running == nil || cs.RestartCount > 0 {
		logResult := AnalyzeContainerLogs(a.client, pod, cs.Name)
		diag.Logs = logResult.Logs
		diag.LogKeywords = logResult.MatchedKeyords

		// å¦‚æœæ—¥å¿—é‡Œå‘ç°äº†ä¸¥é‡é”™è¯¯ï¼Œä¹Ÿå¯ä»¥ç”Ÿæˆä¸€ä¸?Issue
		if len(logResult.MatchedKeyords) > 0 {
			diag.Issues = append(diag.Issues, Issue{
				Type:       "Error",
				Title:      fmt.Sprintf("æ—¥å¿—ä¸­å‘ç°é”™è¯¯ç‰¹å¾? %s", strings.Join(logResult.MatchedKeyords, ", ")),
				Suggestion: "è¯·æŸ¥çœ‹ä¸‹æ–¹è¯¦ç»†æ—¥å¿—å®šä½ä»£ç é—®é¢?,
			})
		}
	}

	return diag
}

// GetResourceInfo æ ¼å¼åŒ–èµ„æºé…ç½?(è¿”å›çº¯å­—ç¬¦ä¸²)
func (a *Analyzer) GetResourceInfo(container corev1.Container) string {
	req := container.Resources.Requests
	lim := container.Resources.Limits

	reqCPU := req.Cpu().String()
	reqMem := req.Memory().String()
	limCPU := lim.Cpu().String()
	limMem := lim.Memory().String()

	// å¤„ç†æœªè®¾ç½®çš„æƒ…å†µ (0)
	if reqCPU == "0" {
		reqCPU = "æœªè®¾ç½?
	}
	if reqMem == "0" {
		reqMem = "æœªè®¾ç½?
	}
	if limCPU == "0" {
		limCPU = "æœªè®¾ç½?
	}
	if limMem == "0" {
		limMem = "æœªè®¾ç½?
	}

	return fmt.Sprintf("CPU(Req=%s/Lim=%s) | Mem(Req=%s/Lim=%s)",
		reqCPU, limCPU, reqMem, limMem)
}

// GetPodEvents è¿”å›å­—ç¬¦ä¸²åˆ‡ç‰?
func (a *Analyzer) GetPodEvents(pod *corev1.Pod) []string {
	var result []string

	// ä½¿ç”¨ FieldSelector è¿‡æ»¤å‡ºæ¶‰åŠè¯¥ Pod çš„äº‹ä»?
	// involvedObject.uid = Pod UID (æ›´ç²¾ç¡®ï¼Œé˜²æ­¢åŒåå†²çª)
	selector := fmt.Sprintf("involvedObject.name=%s,involvedObject.namespace=%s,involvedObject.uid=%s",
		pod.Name, pod.Namespace, pod.UID)

	events, err := a.client.CoreV1().Events(pod.Namespace).List(context.TODO(), metav1.ListOptions{
		FieldSelector: selector,
	})

	if err != nil {
		return []string{fmt.Sprintf("â?è·å–äº‹ä»¶å¤±è´¥: %v", err)}
	}

	if len(events.Items) == 0 {
		return []string{}
	}

	// ä¼˜åŒ–: ä»…ä¿ç•™æœ€è¿?1 å°æ—¶çš„äº‹ä»?
	var recentEvents []corev1.Event
	oneHourAgo := time.Now().Add(-1 * time.Hour)

	// è¾…åŠ©å‡½æ•°: è·å–äº‹ä»¶å‘ç”Ÿçš„æœ€ä½³æ—¶é—?(è§£å†³ [æœªçŸ¥] é—®é¢˜)
	getEventTime := func(e corev1.Event) time.Time {
		if !e.LastTimestamp.IsZero() {
			return e.LastTimestamp.Time
		}
		if !e.EventTime.IsZero() {
			return e.EventTime.Time
		}
		// å¦‚æœéƒ½æ²¡æœ‰ï¼Œå°è¯• FirstTimestamp
		if !e.FirstTimestamp.IsZero() {
			return e.FirstTimestamp.Time
		}
		return time.Time{} // çœŸçš„ä¸€æ— æ‰€æœ?
	}

	for _, e := range events.Items {
		t := getEventTime(e)
		// åªè¦æ—¶é—´æœ‰æ•ˆï¼Œä¸”åœ?å°æ—¶å†…ï¼Œå°±ä¿ç•?
		if !t.IsZero() && t.After(oneHourAgo) {
			recentEvents = append(recentEvents, e)
		}
	}

	// 3. æŒ‰æ—¶é—´æ’åº?(ä½¿ç”¨ recentEvents è€Œä¸æ˜?events.Items)
	sort.Slice(recentEvents, func(i, j int) bool {
		t1 := getEventTime(recentEvents[i])
		t2 := getEventTime(recentEvents[j])
		return t1.Before(t2)
	})

	// 4. æˆªå–æœ€è¿?5 æ?
	start := 0
	if len(recentEvents) > 5 {
		start = len(recentEvents) - 5
	}

	for i := start; i < len(recentEvents); i++ {
		e := recentEvents[i] // âœ?è¿™é‡Œä½¿ç”¨ recentEvents

		// è·å–ç”¨äºå±•ç¤ºçš„æ—¶é—?
		t := getEventTime(e)
		age := TranslateTimestamp(t) // ç¡®ä¿ TranslateTimestamp èƒ½å¤„ç?time.Time

		icon := "ğŸ”¹"
		if e.Type == "Warning" {
			icon = "ğŸ”¸"
		}
		result = append(result, fmt.Sprintf("%s [%s] %s: %s", icon, age, e.Reason, e.Message))
	}

	if len(result) == 0 {
		result = append(result, "æš‚æ— è¿‘æœŸäº‹ä»¶")
	}

	return result
}

================================================================================
?? File Path: \pkg\diagnosis\analyzer_test.go
================================================================================


================================================================================
?? File Path: \pkg\diagnosis\engine.go
================================================================================

package diagnosis

import (
	corev1 "k8s.io/api/core/v1"
)

// RuleEngine ç®¡ç†å¹¶æ‰§è¡Œæ‰€æœ‰æ³¨å†Œçš„è§„åˆ™
type RuleEngine struct {
	rules []Rule
}

// NewRuleEngine åˆå§‹åŒ–å¼•æ“å¹¶åŠ è½½é»˜è®¤è§„åˆ™
func NewRuleEngine() *RuleEngine {
	return &RuleEngine{
		rules: []Rule{
			&OOMRule{},       // æ³¨å†Œ OOM è§„åˆ™
			&ImagePullRule{}, // æ³¨å†Œé•œåƒæ‹‰å–å¤±è´¥è§„åˆ™
			&CrashRule{},     // æ³¨å†Œå´©æºƒå¾ªç¯è§„åˆ™
			&PendingRule{},   // æ³¨å†Œè°ƒåº¦å¤±è´¥è§„åˆ™
		},
	}
}

// Register æ·»åŠ æ–°è§„åˆ?
func (e *RuleEngine) Register(r Rule) {
	e.rules = append(e.rules, r)
}

// Run å¯¹å•ä¸ªå®¹å™¨è¿è¡Œæ‰€æœ‰è§„åˆ™ï¼Œè¿”å›ç¬¬ä¸€ä¸ªå‘½ä¸­çš„ç»“æœ (æˆ–è€…æ”¶é›†æ‰€æœ‰ç»“æ?
// è¿™é‡Œæˆ‘ä»¬é‡‡å–â€œçŸ­è·¯â€ç­–ç•¥ï¼šä¸€æ—¦å‘ç°ä¸¥é‡é—®é¢?Matched=true)ï¼Œå°±è¿”å›
func (e *RuleEngine) Run(pod *corev1.Pod, container *corev1.Container, status corev1.ContainerStatus) *CheckResult {
	for _, rule := range e.rules {
		res := rule.Check(pod, container, status)
		if res.Matched {
			// å‘½ä¸­è§„åˆ™ï¼Œè¿”å›ç»“æ?
			return &res
		}
	}
	return nil // æ²¡æœ‰å‘½ä¸­ä»»ä½•å¼‚å¸¸è§„åˆ™
}

================================================================================
?? File Path: \pkg\diagnosis\log_analyzer.go
================================================================================

package diagnosis

import (
	"bufio"
	"context"
	"fmt"
	"regexp"

	corev1 "k8s.io/api/core/v1"
	"k8s.io/client-go/kubernetes"
)

// å¸¸è§é”™è¯¯æ¨¡å¼åº?
// ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…å„ç§è¯­è¨€/æ¡†æ¶çš„å…¸å‹æŠ¥é”?
var errorPatterns = map[string]*regexp.Regexp{
	"Java Exception":    regexp.MustCompile(`(?i)(Exception|Error):`),
	"Go Panic":          regexp.MustCompile(`panic:`),
	"Python Traceback":  regexp.MustCompile(`Traceback \(most recent call last\):`),
	"Node Error":        regexp.MustCompile(`(?i)ReferenceError|TypeError|SyntaxError`),
	"OOM Message":       regexp.MustCompile(`(?i)Kill process|Out of memory`),
	"Permission Denied": regexp.MustCompile(`(?i)permission denied`),
	"Common Error":      regexp.MustCompile(`(?i)(error|fail|fatal|exception)`),
}

// LogAnalysisResult æ—¥å¿—åˆ†æç»“æœ
type LogAnalysisResult struct {
	Logs           []string // æŠ“å–çš„æœ€åå‡ è¡Œæ—¥å¿?
	MatchedKeyords []string // åŒ¹é…åˆ°çš„é”™è¯¯å…³é”®å­?
}

// AnalyzeContainerLogs è·å–å¹¶åˆ†æå®¹å™¨æ—¥å¿?
func AnalyzeContainerLogs(client kubernetes.Interface, pod *corev1.Pod, containerName string) LogAnalysisResult {
	result := LogAnalysisResult{
		Logs:           []string{},
		MatchedKeyords: []string{},
	}

	// é…ç½®æ—¥å¿—è·å–é€‰é¡¹
	lineLimit := int64(50) // åªçœ‹æœ€å?50 è¡?
	opts := &corev1.PodLogOptions{
		Container: containerName,
		TailLines: &lineLimit,
		// å¦‚æœå®¹å™¨å½“å‰æŒ‚äº†ï¼Œå°è¯•è·å–ä¸Šä¸€æ¬¡è¿è¡Œçš„æ—¥å¿— (Previous)
		// è¿™å¯¹äº?CrashLoopBackOff ç‰¹åˆ«é‡è¦ï¼?
		Previous: isContainerRestarted(pod, containerName),
	}

	req := client.CoreV1().Pods(pod.Namespace).GetLogs(pod.Name, opts)
	stream, err := req.Stream(context.TODO())
	if err != nil {
		// å¦‚æœè·å–å¤±è´¥ï¼ˆæ¯”å¦‚æ²¡æœ?Previous æ—¥å¿—ï¼‰ï¼Œå°è¯•è·å–å½“å‰æ—¥å¿—
		if opts.Previous {
			opts.Previous = false
			req = client.CoreV1().Pods(pod.Namespace).GetLogs(pod.Name, opts)
			stream, err = req.Stream(context.TODO())
		}

		if err != nil {
			result.Logs = append(result.Logs, fmt.Sprintf("â?æ— æ³•è·å–æ—¥å¿—: %v", err))
			return result
		}
	}
	defer stream.Close()

	// æ‰«ææ—¥å¿—
	scanner := bufio.NewScanner(stream)
	uniqueMatches := make(map[string]bool)

	for scanner.Scan() {
		line := scanner.Text()
		result.Logs = append(result.Logs, line)

		// æ­£åˆ™åŒ¹é…
		for name, pattern := range errorPatterns {
			if pattern.MatchString(line) {
				if !uniqueMatches[name] {
					uniqueMatches[name] = true
					result.MatchedKeyords = append(result.MatchedKeyords, name)
				}
			}
		}
	}

	return result
}

// è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­å®¹å™¨æ˜¯å¦é‡å¯è¿‡ï¼ˆå†³å®šæ˜¯å¦åŠ  Previous å‚æ•°ï¼?
func isContainerRestarted(pod *corev1.Pod, containerName string) bool {
	for _, cs := range pod.Status.ContainerStatuses {
		if cs.Name == containerName {
			return cs.RestartCount > 0
		}
	}
	return false
}

================================================================================
?? File Path: \pkg\diagnosis\rules.go
================================================================================

package diagnosis

import (
	"fmt"

	corev1 "k8s.io/api/core/v1"
)

// -----------------------------------------------------------
// OOMRule: æ£€æµ‹å†…å­˜æº¢å‡?
// -----------------------------------------------------------
type OOMRule struct{}

func (r *OOMRule) Name() string {
	return "OOMRule"
}

func (r *OOMRule) Check(pod *corev1.Pod, container *corev1.Container, status corev1.ContainerStatus) CheckResult {
	// æ— è®ºæ˜?Waiting è¿˜æ˜¯ Terminatedï¼Œéƒ½è¦æ£€æŸ?LastTerminationState

	var termState *corev1.ContainerStateTerminated

	// æ£€æŸ¥å½“å‰æ˜¯å?Terminated
	if status.State.Terminated != nil {
		termState = status.State.Terminated
	}
	// æ£€æŸ¥ä¸Šæ¬¡æ˜¯å?Terminated (LastTerminationState)
	if status.LastTerminationState.Terminated != nil {
		// ä¼˜å…ˆå–æœ€æ–°çš„çŠ¶æ€ï¼Œä½†å¦‚æœå½“å‰æ˜¯ Waitingï¼Œæˆ‘ä»¬å°±çœ‹ä¸Šä¸€æ¬?
		if termState == nil {
			termState = status.LastTerminationState.Terminated
		}
	}

	// å¦‚æœæ ¹æœ¬æ²¡æœ‰ç»ˆæ­¢è®°å½•ï¼Œç›´æ¥è·³è¿?
	if termState == nil {
		return CheckResult{Matched: false}
	}

	// æ ¸å¿ƒåˆ¤æ–­: Reason == "OOMKilled"
	if termState.Reason == "OOMKilled" {
		res := CheckResult{
			Matched:  true,
			Title:    "å†…å­˜æº¢å‡º (OOMKilled)",
			RawError: fmt.Sprintf("Exit Code: %s", ExplainExitCode(termState.ExitCode)),
		}

		// èµ„æºå»ºè®®
		if container != nil {
			limit := container.Resources.Limits.Memory()
			if !limit.IsZero() {
				res.Suggestion = fmt.Sprintf("æ£€æµ‹åˆ°å†…å­˜é™åˆ¶ Limit=%sï¼Œå»ºè®®é€‚å½“è°ƒå¤§", limit.String())
			} else {
				res.Suggestion = "æœªè®¾ç½®å†…å­˜é™åˆ¶ï¼Œå»ºè®®è®¾ç½® Limits é˜²æ­¢èŠ‚ç‚¹èµ„æºè€—å°½"
			}
		}
		return res
	}

	return CheckResult{Matched: false}
}

// -----------------------------------------------------------
// ImagePullRule: æ£€æµ‹é•œåƒæ‹‰å–å¤±è´?
// -----------------------------------------------------------
type ImagePullRule struct{}

func (r *ImagePullRule) Name() string {
	return "ImagePullRule"
}

func (r *ImagePullRule) Check(pod *corev1.Pod, container *corev1.Container, status corev1.ContainerStatus) CheckResult {
	// åªå…³å¿?Waiting çŠ¶æ€?
	if status.State.Waiting == nil {
		return CheckResult{Matched: false}
	}

	reason := status.State.Waiting.Reason
	if reason == "ImagePullBackOff" || reason == "ErrImagePull" {
		return CheckResult{
			Matched:    true,
			Title:      fmt.Sprintf("é•œåƒæ‹‰å–å¤±è´¥ (æ— æ³•è·å– %s)", status.Image),
			RawError:   status.State.Waiting.Message,
			Suggestion: "è¯·æ£€æŸ? 1.é•œåƒåæ‹¼å†?2.é•œåƒTagæ˜¯å¦å­˜åœ¨ 3.ç§æœ‰ä»“åº“ImagePullSecretsæƒé™",
		}
	}

	return CheckResult{Matched: false}
}

// -----------------------------------------------------------
// CrashRule: æ£€æµ‹å®¹å™¨åå¤é‡å?(CrashLoopBackOff)
// -----------------------------------------------------------
type CrashRule struct{}

func (r *CrashRule) Name() string {
	return "CrashRule"
}

func (r *CrashRule) Check(pod *corev1.Pod, container *corev1.Container, status corev1.ContainerStatus) CheckResult {
	// å¦‚æœæ˜?Waiting ä¸”åŸå› æ˜¯ CrashLoopBackOff
	if status.State.Waiting != nil && status.State.Waiting.Reason == "CrashLoopBackOff" {
		res := CheckResult{
			Matched:    true,
			Title:      "å®¹å™¨åå¤é‡å¯ (CrashLoopBackOff)",
			RawError:   status.State.Waiting.Message,
			Suggestion: "åº”ç”¨ç¨‹åºå¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥åº”ç”¨æ—¥å¿?(logs) æˆ–é…ç½?,
		}

		// å°è¯•ä»?LastTerminationState è·å–æ›´å¤šä¿¡æ¯
		if status.LastTerminationState.Terminated != nil {
			last := status.LastTerminationState.Terminated
			res.RawError += fmt.Sprintf(" | ä¸Šæ¬¡é€€å‡? %s (%s)",
				ExplainExitCode(last.ExitCode), last.Reason)
		}

		return res
	}
	return CheckResult{Matched: false}
}

================================================================================
?? File Path: \pkg\diagnosis\rule_pending.go
================================================================================

package diagnosis

import (
	corev1 "k8s.io/api/core/v1"
)

// -----------------------------------------------------------
// PendingRule: æ£€æµ‹è°ƒåº¦å¤±è´?
// -----------------------------------------------------------
type PendingRule struct{}

func (r *PendingRule) Name() string {
	return "PendingRule"
}

func (r *PendingRule) Check(pod *corev1.Pod, container *corev1.Container, status corev1.ContainerStatus) CheckResult {
	// Pending çŠ¶æ€ä¸‹ï¼ŒPod å¯èƒ½è¿˜æ²¡æœ?ContainerStatus
	// ä½†æˆ‘ä»¬çš„æ¶æ„æ˜¯éå?ContainerStatus è°ƒç”¨çš„ã€?
	// å¦‚æœ Pod å¤„äº Pendingï¼ŒContainerStatus é‡Œçš„ State é€šå¸¸æ˜?Waiting (ContainerCreating) æˆ–è€…æ ¹æœ¬æ²¡æ•°æ®ã€?

	// è¿™é‡Œæˆ‘ä»¬éœ€è¦ä¸€ç§æœºåˆ¶ï¼šå¦‚æœæ˜?Pendingï¼Œä¸” Reason æ˜?Unschedulable

	// 1. æ£€æŸ?Pod æ•´ä½“çŠ¶æ€?
	if pod.Status.Phase == corev1.PodPending {
		// æ£€æŸ?Pod Conditions é‡Œçš„ PodScheduled å­—æ®µ
		for _, cond := range pod.Status.Conditions {
			if cond.Type == corev1.PodScheduled && cond.Status == corev1.ConditionFalse {
				return CheckResult{
					Matched:    true,
					Title:      "Pod æ— æ³•è°ƒåº¦ (Pending)",
					RawError:   cond.Message,
					Suggestion: "é›†ç¾¤èµ„æºä¸è¶³æˆ–ä¸æ»¡è¶³è°ƒåº¦ç­–ç•¥ (NodeSelector/Taint)ï¼Œè¯·æŸ¥çœ‹ä¸‹æ–¹ Events è¯¦æƒ…",
				}
			}
		}
	}

	return CheckResult{Matched: false}
}

================================================================================
?? File Path: \pkg\diagnosis\types.go
================================================================================

package diagnosis

import (
	corev1 "k8s.io/api/core/v1"
)

// CheckResult ä»£è¡¨å•æ¡è§„åˆ™çš„æ£€æŸ¥ç»“æ?
type CheckResult struct {
	Matched    bool   // æ˜¯å¦å‘½ä¸­äº†è¿™æ¡è§„åˆ?
	Title      string // ç®€çŸ­çš„æ ‡é¢˜ (ä¾‹å¦‚ "å†…å­˜æº¢å‡º")
	Suggestion string // ä¿®å¤å»ºè®® (ä¾‹å¦‚ "å»ºè®®å¢åŠ  Limit")
	RawError   string // åŸå§‹æŠ¥é”™ä¿¡æ¯
}

// Rule æ˜¯æ‰€æœ‰è¯Šæ–­è§„åˆ™å¿…é¡»å®ç°çš„æ¥å£
type Rule interface {
	// Name è¿”å›è§„åˆ™çš„å”¯ä¸€æ ‡è¯†ç¬?
	Name() string

	// Check æ‰§è¡Œæ£€æŸ?
	// å‚æ•°: pod (æ•´ä¸ªPodå¯¹è±¡), container (å½“å‰å®¹å™¨Spec), status (å½“å‰å®¹å™¨çŠ¶æ€?
	Check(pod *corev1.Pod, container *corev1.Container, status corev1.ContainerStatus) CheckResult
}

// -----------------------------------------------------------
// è¯Šæ–­ç»“æœæ•°æ®ç»“æ„
// -----------------------------------------------------------

// DiagnosisResult åŒ…å«ä¸€ä¸?Pod çš„å®Œæ•´è¯Šæ–­ä¿¡æ?
type DiagnosisResult struct {
	PodName      string               `json:"pod_name"`
	Namespace    string               `json:"namespace"`
	NodeName     string               `json:"node_name"`
	Phase        string               `json:"phase"`
	RestartCount int32                `json:"restart_count"`
	Containers   []ContainerDiagnosis `json:"containers"` // å®¹å™¨çº§è¯Šæ–­åˆ—è¡?
	Events       []string             `json:"events"`     // æœ€è¿‘çš„äº‹ä»¶åˆ—è¡¨
}

// ContainerDiagnosis å•ä¸ªå®¹å™¨çš„è¯Šæ–­è¯¦æƒ?
type ContainerDiagnosis struct {
	Name         string   `json:"name"`
	State        string   `json:"state"`         // Waiting, Running, Terminated
	Reason       string   `json:"reason"`        // CrashLoopBackOff, OOMKilled ...
	Message      string   `json:"message"`       // è¯¦ç»†ä¿¡æ¯
	ExitCode     int32    `json:"exit_code"`     // é€€å‡ºç 
	Ready        bool     `json:"ready"`         // æ˜¯å¦å°±ç»ª
	ResourceInfo string   `json:"resource_info"` // CPU/Mem é…ç½®å­—ç¬¦ä¸?
	Issues       []Issue  `json:"issues"`        // å‘ç°çš„é—®é¢?(ç”±è§„åˆ™å¼•æ“äº§å‡?
	Logs         []string `json:"logs"`          // æŠ“å–çš„æœ€åå‡ è¡Œæ—¥å¿?
	LogKeywords  []string `json:"log_keywords"`  // ä»æ—¥å¿—ä¸­æå–çš„å…³é”®è¯
}

// Issue ä»£è¡¨å‘ç°çš„ä¸€ä¸ªå…·ä½“é—®é¢?
type Issue struct {
	Type       string `json:"type"`       // Error (ğŸ›‘) or Warning (âš ï¸)
	Title      string `json:"title"`      // æ ‡é¢˜
	RawError   string `json:"raw_error"`  // åŸå§‹æŠ¥é”™
	Suggestion string `json:"suggestion"` // ä¿®å¤å»ºè®®
}

================================================================================
?? File Path: \pkg\diagnosis\utils.go
================================================================================

package diagnosis

import (
	"fmt"
	"time"

	corev1 "k8s.io/api/core/v1"
)

// ExplainExitCode å°†æ•°å­—é€€å‡ºç è½¬æ¢ä¸ºäººç±»å¯è¯»çš„å­—ç¬¦ä¸?
func ExplainExitCode(code int32) string {
	var exitCodeMap = map[int32]string{
		0:   "Completed (æ­£å¸¸é€€å‡?",
		1:   "General Error (åº”ç”¨å†…éƒ¨é”™è¯¯)",
		2:   "Misuse of Shell Builtins (Shellå†…å»ºå‘½ä»¤è¯¯ç”¨)",
		126: "Invoked Command Cannot Execute (å‘½ä»¤ä¸å¯æ‰§è¡Œ)",
		127: "Command Not Found (å‘½ä»¤æœªæ‰¾åˆ?",
		128: "Invalid Exit Argument (æ— æ•ˆçš„é€€å‡ºå‚æ•?",
		130: "Script Terminated by Control-C (è¢«Ctrl+Cç»ˆæ­¢)",
		137: "SIGKILL (å¼ºåˆ¶ç»ˆæ­¢/OOMKilled - å†…å­˜æº¢å‡º)",
		143: "SIGTERM (ä¼˜é›…ç»ˆæ­¢)",
	}

	if msg, ok := exitCodeMap[code]; ok {
		return fmt.Sprintf("%d (%s)", code, msg)
	}

	if code > 128 {
		return fmt.Sprintf("%d (Signal %d)", code, code-128)
	}

	return fmt.Sprintf("%d (æœªçŸ¥é”™è¯¯ç ?", code)
}

// SumRestarts è®¡ç®—é‡å¯æ€»æ•°
func SumRestarts(pod *corev1.Pod) int32 {
	var count int32
	for _, cs := range pod.Status.ContainerStatuses {
		count += cs.RestartCount
	}
	return count
}

// TranslateTimestamp ç¿»è¯‘æ—¶é—´æˆ?
func TranslateTimestamp(t time.Time) string {
	if t.IsZero() {
		return "æœªçŸ¥"
	}
	duration := time.Since(t)
	if duration.Seconds() < 60 {
		return fmt.Sprintf("%.0fç§’å‰", duration.Seconds())
	}
	if duration.Minutes() < 60 {
		return fmt.Sprintf("%.0fåˆ†é’Ÿå‰?, duration.Minutes())
	}
	return fmt.Sprintf("%.0få°æ—¶å‰?, duration.Hours())
}

================================================================================
?? File Path: \pkg\k8s\client.go
================================================================================

package k8s

import (
	"flag"
	"path/filepath"

	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/util/homedir"
)

// Client å°è£…äº?Kubernetes å®¢æˆ·ç«¯é›†
type Client struct {
	Clientset *kubernetes.Clientset
}

// NewClient åˆå§‹åŒ–å¹¶è¿”å›ä¸€ä¸?K8s å®¢æˆ·ç«?
func NewClient() (*Client, error) {
	var kubeconfig *string

	// å°è¯•å¯»æ‰¾ kubeconfig æ–‡ä»¶
	if home := homedir.HomeDir(); home != "" {
		path := filepath.Join(home, ".kube", "config")
		kubeconfig = flag.String("kubeconfig", path, "(optional) absolute path to the kubeconfig file")
	} else {
		path := ""
		kubeconfig = &path
	}

	// æ³¨æ„ï¼šè¿™é‡Œä¸ºäº†å…¼å®?Cobraï¼Œæˆ‘ä»¬æš‚æ—¶æ‰‹åŠ¨è§£æä¸€ä¸?flagï¼Œæˆ–è€…ç›´æ¥æ„å»ºé…ç½?
	// åœ¨å®é™?CLI ä¸­ï¼Œé€šå¸¸ç”?Cobra å¤„ç† flagï¼Œè¿™é‡Œæˆ‘ä»¬ç®€åŒ–å¤„ç†ï¼Œç›´æ¥è¯»å–é»˜è®¤è·¯å¾„
	// å¦‚æœæƒ³è¦æ›´ä¸¥è°¨ï¼Œå¯ä»¥ä½¿ç”¨ clientcmd.BuildConfigFromFlags("", *kubeconfig)
	// ä½†ä¸ºäº†ç¡®ä¿åœ¨è¿™ä¸€æ­¥ä¸å‡ºé”™ï¼Œæˆ‘ä»¬ç›´æ¥åŠ è½?

	config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
	if err != nil {
		return nil, err
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return nil, err
	}

	return &Client{
		Clientset: clientset,
	}, nil
}

================================================================================
?? File Path: \pkg\report\html.go
================================================================================

package report

import (
	"html/template"
	"os"
	"time"

	"github.com/swfoodt/kubehealer/pkg/diagnosis"
)

// HTMLData ä¼ ç»™æ¨¡æ¿çš„æ•°æ®ç»“æ?
// æŠ?DiagnosisResult åŒ…è£…ä¸€ä¸‹ï¼ŒåŠ ä¸ªâ€œç”Ÿæˆæ—¶é—´â€å­—æ®?
type HTMLData struct {
	diagnosis.DiagnosisResult
	GenerateTime string
}

// GenerateHTML ç”Ÿæˆ HTML æ–‡ä»¶
func GenerateHTML(result diagnosis.DiagnosisResult, filename string) error {
	// 1. å‡†å¤‡æ•°æ®
	data := HTMLData{
		DiagnosisResult: result,
		GenerateTime:    time.Now().Format("2006-01-02 15:04:05"),
	}

	// 2. è§£ææ¨¡æ¿ (ä»?templates.go ä¸­çš„å¸¸é‡è¯»å–)
	tmpl, err := template.New("report").Parse(HTMLTemplate)
	if err != nil {
		return err
	}

	// 3. åˆ›å»ºæ–‡ä»¶
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	// 4. æ¸²æŸ“
	return tmpl.Execute(f, data)
}

================================================================================
?? File Path: \pkg\report\markdown.go
================================================================================

package report

import (
	"fmt"
	"strings"
	"time"

	"github.com/swfoodt/kubehealer/pkg/diagnosis"
)

// GenerateMarkdown ç”Ÿæˆ Markdown æ ¼å¼çš„è¯Šæ–­æŠ¥å‘?
func GenerateMarkdown(result diagnosis.DiagnosisResult) string {
	var sb strings.Builder

	// æ ‡é¢˜ä¸å…ƒæ•°æ®
	sb.WriteString(fmt.Sprintf("# ğŸš‘ KubeHealer è¯Šæ–­æŠ¥å‘Š: %s\n\n", result.PodName))
	sb.WriteString(fmt.Sprintf("> ç”Ÿæˆæ—¶é—´: %s\n\n", time.Now().Format("2006-01-02 15:04:05")))

	// åŸºç¡€ä¿¡æ¯è¡¨æ ¼
	sb.WriteString("## 1. åŸºç¡€ä¿¡æ¯\n\n")
	sb.WriteString("| æŒ‡æ ‡ | å€?|\n")
	sb.WriteString("| :--- | :--- |\n")
	sb.WriteString(fmt.Sprintf("| **Pod åç§°** | `%s` |\n", result.PodName))
	sb.WriteString(fmt.Sprintf("| **å‘½åç©ºé—´** | `%s` |\n", result.Namespace))
	sb.WriteString(fmt.Sprintf("| **æ‰€åœ¨èŠ‚ç‚?* | `%s` |\n", result.NodeName))
	sb.WriteString(fmt.Sprintf("| **å½“å‰çŠ¶æ€?* | **%s** |\n", result.Phase))
	sb.WriteString(fmt.Sprintf("| **é‡å¯æ¬¡æ•°** | %d |\n\n", result.RestartCount))

	// å®¹å™¨åˆ†æ
	sb.WriteString("## 2. å®¹å™¨æ·±åº¦åˆ†æ\n\n")
	for _, c := range result.Containers {
		icon := "âœ?
		if c.State != "Running" {
			icon = "âš ï¸"
		}
		// å¦‚æœæœ?Error çº§åˆ«çš?Issue
		for _, issue := range c.Issues {
			if issue.Type == "Error" {
				icon = "ğŸ›‘"
				break
			}
		}

		sb.WriteString(fmt.Sprintf("### %s å®¹å™¨: %s\n\n", icon, c.Name))
		sb.WriteString(fmt.Sprintf("- **çŠ¶æ€?*: %s\n", c.State))
		sb.WriteString(fmt.Sprintf("- **èµ„æºé…ç½®**: `%s`\n", strings.ReplaceAll(c.ResourceInfo, "\n", " ")))

		if c.Reason != "" {
			sb.WriteString(fmt.Sprintf("- **åŸå› **: %s\n", c.Reason))
		}
		if c.Message != "" {
			sb.WriteString(fmt.Sprintf("- **è¯¦ç»†ä¿¡æ¯**: %s\n", c.Message))
		}
		if c.ExitCode != 0 {
			sb.WriteString(fmt.Sprintf("- **é€€å‡ºç **: %d\n", c.ExitCode))
		}

		// è¯Šæ–­å»ºè®®åŒºåŸŸ
		if len(c.Issues) > 0 {
			sb.WriteString("\n**ğŸ” è¯Šæ–­å‘ç°:**\n\n")
			for _, issue := range c.Issues {
				prefix := "âš ï¸"
				if issue.Type == "Error" {
					prefix = "ğŸ›‘"
				}
				sb.WriteString(fmt.Sprintf("> %s **%s**\n", prefix, issue.Title))
				if issue.RawError != "" {
					sb.WriteString(fmt.Sprintf("> *åŸå§‹æŠ¥é”™: %s*\n", issue.RawError))
				}
				if issue.Suggestion != "" {
					sb.WriteString(fmt.Sprintf("> **ğŸ’¡ ä¿®å¤å»ºè®®**: %s\n", issue.Suggestion))
				}
				sb.WriteString(">\n") // ç©ºè¡Œåˆ†éš”
			}
		}
		sb.WriteString("\n---\n\n")
	}

	// äº‹ä»¶åˆ—è¡¨
	sb.WriteString("## 3. æœ€è¿‘äº‹ä»?(Events)\n\n")
	if len(result.Events) == 0 {
		sb.WriteString("*æš‚æ— äº‹ä»¶è®°å½•*\n")
	} else {
		for _, e := range result.Events {
			sb.WriteString(fmt.Sprintf("- %s\n", e))
		}
	}

	return sb.String()
}

================================================================================
?? File Path: \pkg\report\table.go
================================================================================

package report

import (
	"fmt"
	"os"
	"strings"

	"github.com/olekukonko/tablewriter"
	"github.com/swfoodt/kubehealer/pkg/diagnosis"
)

// PrintTable å°†è¯Šæ–­ç»“æœæ¸²æŸ“ä¸ºç»ˆç«¯è¡¨æ ¼
func PrintTable(result diagnosis.DiagnosisResult) {
	fmt.Println()
	printBasicInfo(result)
	fmt.Println()
	printContainerInfo(result)
	fmt.Println()
	printEvents(result)
	fmt.Println()
}

func printBasicInfo(result diagnosis.DiagnosisResult) {
	data := [][]string{
		{"Pod åç§°", result.PodName},
		{"å‘½åç©ºé—´", result.Namespace},
		{"æ‰€åœ¨èŠ‚ç‚?, result.NodeName},
		{"å½“å‰çŠ¶æ€?, result.Phase},
		{"é‡å¯æ€»æ•°", fmt.Sprintf("%d æ¬?, result.RestartCount)},
	}

	table := tablewriter.NewWriter(os.Stdout)
	table.SetHeader([]string{"åŸºç¡€ä¿¡æ¯", "å€?})
	table.SetBorder(false)
	table.SetColumnColor(
		tablewriter.Colors{tablewriter.Bold, tablewriter.FgHiCyanColor},
		tablewriter.Colors{tablewriter.Normal},
	)
	table.AppendBulk(data)
	table.Render()
}

func printContainerInfo(result diagnosis.DiagnosisResult) {
	table := tablewriter.NewWriter(os.Stdout)
	table.SetHeader([]string{"å®¹å™¨", "çŠ¶æ€?, "èµ„æºé…ç½®", "è¯Šæ–­è¯¦æƒ…"})
	table.SetRowLine(true) // æ˜¾ç¤ºè¡Œåˆ†å‰²çº¿

	for _, c := range result.Containers {
		// æ„é€ è¯Šæ–­è¯¦æƒ…æ–‡æœ?(Reason + Message + Issues)
		var details []string

		// 1. åŸºç¡€åŸå› 
		if c.Reason != "" {
			details = append(details, fmt.Sprintf("Reason: %s", c.Reason))
		}
		if c.Message != "" {
			// å¦‚æœ Message å¤ªé•¿ï¼Œæˆªæ–­ä¸€ä¸‹ï¼Œæˆ–è€…æ¢è¡Œæ˜¾ç¤?
			details = append(details, fmt.Sprintf("Msg: %s", c.Message))
		}
		if c.ExitCode != 0 {
			details = append(details, fmt.Sprintf("ExitCode: %d", c.ExitCode))
		}

		// 2. è§„åˆ™å¼•æ“å‘ç°çš„é—®é¢?(åŠ ç²—/çº¢è‰²)
		for _, issue := range c.Issues {
			prefix := "âš ï¸"
			if issue.Type == "Error" {
				prefix = "ğŸ›‘"
			}
			details = append(details, fmt.Sprintf("%s %s", prefix, issue.Title))
			if issue.Suggestion != "" {
				details = append(details, fmt.Sprintf("   ğŸ’¡ %s", issue.Suggestion))
			}
		}

		// 3. èµ„æºä¿¡æ¯ç®€åŒ–æ˜¾ç¤?
		resInfo := strings.ReplaceAll(c.ResourceInfo, " | ", "\n")

		table.Append([]string{
			c.Name,
			c.State,
			resInfo,
			strings.Join(details, "\n"),
		})
	}

	fmt.Println("ğŸ“‹ å®¹å™¨åˆ†æ:")
	table.Render()
}

func printEvents(result diagnosis.DiagnosisResult) {
	if len(result.Events) == 0 {
		return
	}

	// ç›´æ¥æ‰“å°æ–‡æœ¬åˆ—è¡¨
	fmt.Println("ğŸ•’ æœ€è¿‘äº‹ä»?(Events):")
	for _, e := range result.Events {
		fmt.Println("  " + e)
	}
}

================================================================================
?? File Path: \pkg\report\templates.go
================================================================================

package report

// HTMLTemplate å®šä¹‰äº†è¯Šæ–­æŠ¥å‘Šçš„ç½‘é¡µç»“æ„
// ä½¿ç”¨äº?Bootstrap 5 è¿›è¡Œç¾åŒ–
const HTMLTemplate = `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KubeHealer è¯Šæ–­æŠ¥å‘Š - {{ .PodName }}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { background-color: #f8f9fa; padding-top: 20px; }
        .card { margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .status-running { color: #198754; font-weight: bold; }
        .status-waiting { color: #ffc107; font-weight: bold; }
        .status-terminated { color: #dc3545; font-weight: bold; }
        .issue-error { border-left: 5px solid #dc3545; background-color: #fff5f5; }
        .issue-warning { border-left: 5px solid #ffc107; background-color: #fff3cd; }
        .event-icon { width: 20px; display: inline-block; text-align: center; }
		/* æ—¶é—´è½´æ ·å¼?*/
        .timeline { border-left: 2px solid #dee2e6; padding: 10px 0; margin-left: 20px; }
        .timeline-item { position: relative; padding-left: 30px; margin-bottom: 15px; }
        .timeline-item::before { 
            content: ''; position: absolute; left: -6px; top: 5px; width: 10px; height: 10px; 
            border-radius: 50%; background-color: #0d6efd; border: 2px solid #fff; 
        }
        .timeline-item.warning::before { background-color: #ffc107; }
        .timeline-date { font-size: 0.85em; color: #6c757d; margin-bottom: 2px; }
    </style>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="text-center mb-4">
            <h1>ğŸš‘ KubeHealer è¯Šæ–­æŠ¥å‘Š</h1>
            <p class="text-muted">ç”Ÿæˆæ—¶é—´: {{ .GenerateTime }}</p>
        </div>

        <div class="card">
            <div class="card-header bg-primary text-white">åŸºç¡€ä¿¡æ¯</div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-3"><strong>Pod åç§°:</strong> {{ .PodName }}</div>
                    <div class="col-md-3"><strong>å‘½åç©ºé—´:</strong> {{ .Namespace }}</div>
                    <div class="col-md-3"><strong>æ‰€åœ¨èŠ‚ç‚?</strong> {{ .NodeName }}</div>
                    <div class="col-md-3"><strong>é‡å¯æ¬¡æ•°:</strong> <span class="badge bg-secondary">{{ .RestartCount }}</span></div>
                </div>
                <div class="mt-2">
                    <strong>å½“å‰çŠ¶æ€?</strong> <span class="badge bg-info text-dark">{{ .Phase }}</span>
                </div>
            </div>
        </div>

        <h3>å®¹å™¨æ·±åº¦åˆ†æ</h3>
        {{ range .Containers }}
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <span>ğŸ“¦ å®¹å™¨: <strong>{{ .Name }}</strong></span>
                <span class="badge {{ if eq .State "Running" }}bg-success{{ else }}bg-warning{{ end }}">{{ .State }}</span>
            </div>
            <div class="card-body">
                <p><strong>èµ„æºé…ç½®:</strong> <code>{{ .ResourceInfo }}</code></p>
                
                {{ if .Reason }}
                <p><strong>åŸå› :</strong> {{ .Reason }}</p>
                {{ end }}

                {{ if .Message }}
                <div class="alert alert-secondary" role="alert">
                    <strong>è¯¦ç»†ä¿¡æ¯:</strong> {{ .Message }}
                </div>
                {{ end }}

                {{ range .Issues }}
                <div class="alert {{ if eq .Type "Error" }}issue-error{{ else }}issue-warning{{ end }}">
                    <h5 class="alert-heading">
                        {{ if eq .Type "Error" }}ğŸ›‘{{ else }}âš ï¸{{ end }} {{ .Title }}
                    </h5>
                    {{ if .RawError }}
                    <p class="mb-1 text-muted"><small>åŸå§‹æŠ¥é”™: {{ .RawError }}</small></p>
                    {{ end }}
                    {{ if .Suggestion }}
                    <hr>
                    <p class="mb-0"><strong>ğŸ’¡ ä¿®å¤å»ºè®®:</strong> {{ .Suggestion }}</p>
                    {{ end }}
                </div>
                {{ end }}

				{{ if .Logs }}
                <div class="mt-3">
                    <button class="btn btn-outline-secondary btn-sm" type="button" data-bs-toggle="collapse" data-bs-target="#logs-{{ .Name }}">
                        ğŸ“„ æŸ¥çœ‹å®¹å™¨æ—¥å¿— (æœ€å?{{ len .Logs }} è¡?
                    </button>
                    {{ if .LogKeywords }}
                    <span class="badge bg-danger ms-2">å‘ç°å…³é”®è¯? {{ range .LogKeywords }}{{ . }} {{ end }}</span>
                    {{ end }}
                    
                    <div class="collapse mt-2" id="logs-{{ .Name }}">
                        <div class="card card-body bg-dark text-white font-monospace" style="font-size: 0.85em; max-height: 300px; overflow-y: auto;">
                            {{ range .Logs }}
                            <div>{{ . }}</div>
                            {{ end }}
                        </div>
                    </div>
                </div>
                {{ end }}
            </div>
        </div>
        {{ end }}

        <h3>æœ€è¿‘äº‹ä»?(Timeline)</h3>
        <div class="card">
            <div class="card-body">
                {{ if not .Events }}
                    <p class="text-muted">æš‚æ— äº‹ä»¶è®°å½•</p>
                {{ else }}
                    <div class="timeline">
                    {{ range .Events }}
                        <div class="timeline-item">
                            <div class="timeline-content">{{ . }}</div>
                        </div>
                    {{ end }}
                    </div>
                {{ end }}
            </div>
        </div>
        
        <footer class="text-center mt-4 mb-4 text-muted">
            <small>Generated by KubeHealer</small>
        </footer>
    </div>
</body>
</html>
`

================================================================================
?? File Path: \pkg\util\logger.go
================================================================================

package util

import (
	"os"

	"github.com/sirupsen/logrus"
)

// InitLogger åˆå§‹åŒ–å…¨å±€æ—¥å¿—é…ç½®
func InitLogger(debug bool) {
	// è®¾ç½®è¾“å‡ºåˆ°æ ‡å‡†è¾“å‡?
	logrus.SetOutput(os.Stdout)

	// è®¾ç½®æ—¥å¿—æ ¼å¼ä¸ºæ–‡æœ¬æ ¼å¼?(å¸¦æœ‰é¢œè‰²)
	// å¦‚æœåœ¨ç”Ÿäº§å®¹å™¨é‡Œï¼Œé€šå¸¸ä¼šè®¾ä¸?&logrus.JSONFormatter{}
	logrus.SetFormatter(&logrus.TextFormatter{
		FullTimestamp:   true,
		TimestampFormat: "2006-01-02 15:04:05",
		ForceColors:     true,
	})

	// è®¾ç½®æ—¥å¿—çº§åˆ«
	if debug {
		logrus.SetLevel(logrus.DebugLevel)
		logrus.Debug("ğŸ”§ Debug æ¨¡å¼å·²å¼€å?)
	} else {
		logrus.SetLevel(logrus.InfoLevel)
	}
}

================================================================================
?? File Path: \test\manifests\crash-pod.yaml
================================================================================

# test/manifests/crash-pod.yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: crash-pod
  spec:
    containers:
    - name: error-container
      image: busybox
      # å®¹å™¨å¯åŠ¨åæ‰§è¡Œçš„å‘½ä»¤ï¼Œsleep 5 ç§’åç«‹å³é€€å‡? æ•…æ„è¾“å‡º panic å­—æ ·ï¼Œè§¦å‘æ­£åˆ?,å…ˆç­‰5ç§’å†æ­?
      command: ["sh", "-c", "echo 'Application starting...'; echo 'panic: runtime error: index out of range'; sleep 5; exit 1"]

================================================================================
?? File Path: \test\manifests\image-error-pod.yaml
================================================================================

apiVersion: v1
kind: Pod
metadata:
  name: image-error-pod
spec:
  containers:
  - name: typo-container
    # è¿™æ˜¯ä¸€ä¸ªæ•…æ„å†™é”™çš„é•œåƒåï¼Œæ‹‰ä¸ä¸‹æ¥
    image: nginx:1.99.99-not-exist

================================================================================
?? File Path: \test\manifests\oom-pod.yaml
================================================================================

apiVersion: v1
kind: Pod
metadata:
  name: oom-pod
spec:
  containers:
  - name: memory-eater
    image: polinux/stress
    # å‹åŠ›æµ‹è¯•ï¼šå°è¯•ç”³è¯?150M å†…å­˜
    command: ["stress", "--vm", "1", "--vm-bytes", "150M", "--vm-hang", "1"]
    resources:
      limits:
        # ä¸Šé™åªç»™ 100Mï¼Œè‚¯å®šä¸å¤Ÿï¼Œå¿…æ­»æ— ç–‘
        memory: "100Mi"
      requests:
        memory: "50Mi"

================================================================================
?? File Path: \test\manifests\pending-pod.yaml
================================================================================

apiVersion: v1
kind: Pod
metadata:
  name: pending-pod
spec:
  containers:
  - name: giant-eater
    image: nginx
    resources:
      requests:
        # ç”³è¯· 100ä¸?CPU å’?100G å†…å­˜ï¼Œå¯¼è‡?Pod ä¸€ç›´å¤„äº?Pending çŠ¶æ€?
        cpu: "100"
        memory: "100Gi"

================================================================================
?? File Path: \go.mod
================================================================================

module github.com/swfoodt/kubehealer

go 1.24.3

require (
	github.com/olekukonko/tablewriter v0.0.5
	github.com/sirupsen/logrus v1.9.3
	github.com/spf13/cobra v1.10.2
	github.com/spf13/viper v1.21.0
	k8s.io/api v0.34.2
	k8s.io/apimachinery v0.34.2
	k8s.io/client-go v0.34.2
)

require (
	github.com/clipperhouse/stringish v0.1.1 // indirect
	github.com/clipperhouse/uax29/v2 v2.3.0 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/emicklei/go-restful/v3 v3.12.2 // indirect
	github.com/fsnotify/fsnotify v1.9.0 // indirect
	github.com/fxamacker/cbor/v2 v2.9.0 // indirect
	github.com/go-logr/logr v1.4.2 // indirect
	github.com/go-openapi/jsonpointer v0.21.0 // indirect
	github.com/go-openapi/jsonreference v0.20.2 // indirect
	github.com/go-openapi/swag v0.23.0 // indirect
	github.com/go-viper/mapstructure/v2 v2.4.0 // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/google/gnostic-models v0.7.0 // indirect
	github.com/google/go-cmp v0.7.0 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/mattn/go-runewidth v0.0.19 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.3-0.20250322232337-35a7c28c31ee // indirect
	github.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 // indirect
	github.com/pelletier/go-toml/v2 v2.2.4 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/sagikazarmark/locafero v0.12.0 // indirect
	github.com/spf13/afero v1.15.0 // indirect
	github.com/spf13/cast v1.10.0 // indirect
	github.com/spf13/pflag v1.0.10 // indirect
	github.com/subosito/gotenv v1.6.0 // indirect
	github.com/x448/float16 v0.8.4 // indirect
	go.yaml.in/yaml/v2 v2.4.2 // indirect
	go.yaml.in/yaml/v3 v3.0.4 // indirect
	golang.org/x/net v0.38.0 // indirect
	golang.org/x/oauth2 v0.27.0 // indirect
	golang.org/x/sys v0.39.0 // indirect
	golang.org/x/term v0.30.0 // indirect
	golang.org/x/text v0.31.0 // indirect
	golang.org/x/time v0.9.0 // indirect
	google.golang.org/protobuf v1.36.5 // indirect
	gopkg.in/evanphx/json-patch.v4 v4.12.0 // indirect
	gopkg.in/inf.v0 v0.9.1 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	k8s.io/klog/v2 v2.130.1 // indirect
	k8s.io/kube-openapi v0.0.0-20250710124328-f3f2b991d03b // indirect
	k8s.io/utils v0.0.0-20250604170112-4c0f3b243397 // indirect
	sigs.k8s.io/json v0.0.0-20241014173422-cfa47c3a1cc8 // indirect
	sigs.k8s.io/randfill v1.0.0 // indirect
	sigs.k8s.io/structured-merge-diff/v6 v6.3.0 // indirect
	sigs.k8s.io/yaml v1.6.0 // indirect
)
